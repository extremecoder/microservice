name: Install ALB Controller and Deploy Service

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Update kubeconfig for EKS
      run: aws eks update-kubeconfig --region us-east-1 --name eks1

    - name: Clean up previous webhook configurations
      run: |
        # Remove existing webhook configurations that might be blocking operations
        kubectl delete mutatingwebhookconfiguration aws-load-balancer-webhook --ignore-not-found
        kubectl delete validatingwebhookconfiguration aws-load-balancer-webhook --ignore-not-found
        kubectl delete -n kube-system service aws-load-balancer-webhook-service --ignore-not-found
        kubectl delete -n kube-system deployment aws-load-balancer-controller --ignore-not-found
        kubectl delete crd ingressclassparams.elbv2.k8s.aws --ignore-not-found
        kubectl delete crd targetgroupbindings.elbv2.k8s.aws --ignore-not-found

    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: 'v3.12.3'

    - name: Create IAM Policy for ALB Controller
      run: |
        curl -o iam-policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/main/docs/install/iam_policy.json
        aws iam create-policy \
            --policy-name AWSLoadBalancerControllerIAMPolicy \
            --policy-document file://iam-policy.json || echo "Policy may already exist"

    - name: Get AWS Account ID
      id: get-aws-account
      run: |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
        echo "account_id=$AWS_ACCOUNT_ID" >> $GITHUB_OUTPUT

    - name: Create Service Account
      run: |
        eksctl create iamserviceaccount \
          --cluster=eks1 \
          --namespace=kube-system \
          --name=aws-load-balancer-controller \
          --attach-policy-arn=arn:aws:iam::${{ steps.get-aws-account.outputs.account_id }}:policy/AWSLoadBalancerControllerIAMPolicy \
          --override-existing-serviceaccounts \
          --approve

    - name: Install cert-manager
      run: |
        kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.1/cert-manager.yaml
        echo "Waiting for cert-manager to be ready..."
        kubectl wait --for=condition=Available deployment --all -n cert-manager --timeout=180s || true

    - name: Install ALB Controller with Helm
      run: |
        # First apply CRDs separately
        kubectl apply -k "github.com/aws/eks-charts/stable/aws-load-balancer-controller/crds?ref=master" || echo "CRD installation failed but continuing"
        
        # Add and update Helm repo
        helm repo add eks https://aws.github.io/eks-charts
        helm repo update
        
        # Get VPC ID
        VPC_ID=$(aws eks describe-cluster --name eks1 --query "cluster.resourcesVpcConfig.vpcId" --output text)
        
        # Install controller
        helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
          -n kube-system \
          --set clusterName=eks1 \
          --set serviceAccount.create=false \
          --set serviceAccount.name=aws-load-balancer-controller \
          --set region=us-east-1 \
          --set vpcId=$VPC_ID
        
        # Wait for controller to be ready
        echo "Waiting for AWS Load Balancer Controller to be ready..."
        sleep 30
        kubectl get deployment -n kube-system aws-load-balancer-controller

    - name: Update Kubernetes Manifest
      run: |
        # Create a updated manifest with correct ingressClassName
        cat > k8s/updated-quantum-manifest.yaml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: quantum-microservice-deployment
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: quantum-microservice
          template:
            metadata:
              labels:
                app: quantum-microservice
            spec:
              containers:
              - name: quantum-microservice
                image: abhishekt/quantum-microservice:latest
                imagePullPolicy: Always
                ports:
                - containerPort: 8889
                env:
                - name: IBM_QUANTUM_TOKEN
                  valueFrom:
                    secretKeyRef:
                      name: ibm-quantum-secret
                      key: token
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: quantum-microservice-service
        spec:
          selector:
            app: quantum-microservice
          type: ClusterIP
          ports:
            - protocol: TCP
              port: 8889
              targetPort: 8889
        ---
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: quantum-microservice-ingress
          annotations:
            alb.ingress.kubernetes.io/scheme: internet-facing
            alb.ingress.kubernetes.io/target-type: ip
            alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}, {"HTTP":80}]'
            alb.ingress.kubernetes.io/ssl-redirect: '443'
        spec:
          ingressClassName: alb
          rules:
            - http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: quantum-microservice-service
                      port:
                        number: 8889
        EOF

    - name: Deploy Quantum Microservice
      run: |
        # Create IBM Quantum secret if needed
        kubectl create secret generic ibm-quantum-secret \
          --from-literal=token=${{ secrets.IBM_QUANTUM_TOKEN }} \
          --dry-run=client -o yaml | kubectl apply -f -
          
        # Apply the updated manifest
        kubectl apply -f k8s/updated-quantum-manifest.yaml
        
    - name: Get Ingress Address
      run: |
        echo "Waiting for ALB to be provisioned (this may take a few minutes)..."
        sleep 60
        kubectl get ingress quantum-microservice-ingress